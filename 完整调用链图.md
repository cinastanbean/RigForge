# RigForge 完整调用链路

本文档详细描述 RigForge 项目从服务启动到请求处理的完整函数调用链路。

## 目录

1. [服务启动阶段](#1️⃣-服务启动阶段)
2. [模块初始化阶段](#2️⃣-模块初始化阶段)
3. [请求处理阶段](#3️⃣-请求处理阶段)
4. [完整调用链图](#完整调用链图)
5. [关键函数入口点](#关键函数入口点)

---

## 1️⃣ 服务启动阶段

### 终端命令执行

```bash
# 用户执行启动命令
./scripts/server.sh restart fg
```

### server.sh 脚本执行

```bash
# server.sh 执行流程
start_fg() {
    echo "Starting server in foreground: http://${HOST}:${PORT}"
    cd "${ROOT_DIR}"
    exec env PYTHONPATH="${PYTHONPATH_VALUE}" /opt/anaconda3/bin/uvicorn "${APP_MODULE}" --host "${HOST}" --port "${PORT}"
}
```

### uvicorn 启动

```bash
# uvicorn 启动命令
uvicorn rigforge.main:app --host 127.0.0.1 --port 8000
```

**作用**：
- 加载 `rigforge.main` 模块
- 获取 `app` 对象
- 启动 ASGI 服务器监听请求

---

## 2️⃣ 模块初始化阶段

### main.py 模块级代码执行顺序

```python
# 1. 导入依赖
from pathlib import Path
from fastapi import FastAPI, FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from dotenv import load_dotenv

from .csv_runtime_db import rebuild_runtime_db
from .db import SQLitePartsRepository
from .graph import RigForgeGraph
from .schemas import ChatRequest
from .service import ChatService
from .tools import Toolset, pick_build_from_candidates

# 2. 定义常量
ROOT = Path(__file__).resolve().parents[2]
FRONTEND_DIR = ROOT / "frontend"
RUNTIME_PARTS_DB_PATH = ROOT / "data" / "agent_parts.db"
METRICS_DB_PATH = ROOT / "data" / "metrics.db"
CSV_JD_PATH = ROOT / "data" / "data_jd.csv"
CSV_NEWEGG_PATH = ROOT / "data" / "data_newegg.csv"

# 3. 加载环境变量
load_dotenv(ROOT / ".env")

# 4. 定义辅助函数
def _env_int(name: str, default: int) -> int:
    """从环境变量读取整数"""

def _normalize_mode(mode: str) -> BuildDataMode:
    """规范化数据模式"""

def _bootstrap_parts_repo():
    """初始化配件仓库"""

def _build_graph_service(repo, mode):
    """构建图服务"""

def _live_preview_build(mode, result):
    """实时预览构建"""

# 5. 初始化配件仓库
_bootstrap_parts_repo()
    ↓
# 检查数据库是否需要重建
if not RUNTIME_PARTS_DB_PATH.exists() or need_rebuild:
    rebuild_runtime_db(RUNTIME_PARTS_DB_PATH, CSV_JD_PATH, CSV_NEWEGG_PATH)
    ↓
# 创建仓库实例
repo_all = SQLitePartsRepository(RUNTIME_PARTS_DB_PATH)
repo_jd = SQLitePartsRepository(RUNTIME_PARTS_DB_PATH, source_sites={"jd"})
repo_newegg = SQLitePartsRepository(RUNTIME_PARTS_DB_PATH, source_sites={"newegg"})

# 6. 创建聊天服务
services: Dict[BuildDataMode, ChatService] = {
    "jd_newegg": _build_graph_service(repo_all, "jd_newegg"),
    "jd": _build_graph_service(repo_jd, "jd"),
    "newegg": _build_graph_service(repo_newegg, "newegg"),
}

service = services["jd_newegg"]  # 默认服务

def _build_graph_service(repo, mode):
    """构建图服务"""
    # 创建工具集
    toolset = Toolset(
        repo,
        build_data_source=source_label,
        build_data_version="latest",
        build_data_mode=mode,
    )

    # 创建图引擎
    graph = RigForgeGraph(toolset)

    # 创建聊天服务
    return ChatService(
        graph,
        metrics_db_path=METRICS_DB_PATH,
        session_store="sqlite",
        session_redis_url=None,
        session_ttl_seconds=7 * 24 * 3600,
        session_cleanup_interval_seconds=3600,
    )

# 7. 创建 FastAPI 应用
app = FastAPI(title="RigForge｜锐格锻造坊")

# 8. 添加 CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 9. 挂载静态文件
app.mount("/static", StaticFiles(directory=FRONTEND_DIR), name="static")

# 10. 定义路由
@app.get("/") → index()
@app.get("/favicon.ico") → favicon()
@app.post("/api/chat") → chat()
@app.get("/api/parts") → list_parts()
@app.get("/api/metrics") → metrics()
```

---

## 3️⃣ 请求处理阶段

### 用户发起请求

```http
POST /api/chat
Content-Type: application/json

{
    "session_id": "user123",
    "message": "我想配一台游戏电脑，预算9000元",
    "interaction_mode": "chat",
    "enthusiasm_level": "standard",
    "build_data_mode": "jd_newegg"
}
```

### FastAPI 路由到 chat() 函数

```python
@app.post("/api/chat")
def chat(payload: ChatRequest):
    """聊天 API"""
    # 1. 规范化模式
    mode = _normalize_mode(payload.build_data_mode)

    # 2. 路由会话 ID
    routed_session_id = f"{mode}:{payload.session_id}"

    # 3. 选择服务
    active_service = service if mode == "jd_newegg" else services[mode]

    # 4. 调用聊天服务
    result = active_service.chat(
        routed_session_id,
        payload.message,
        payload.interaction_mode,
        payload.enthusiasm_level
    )

    # 5. 生成预览
    _live_preview_build(mode, result)

    # 6. 返回响应
    return result.model_dump()
```

### ChatService.chat() 执行

```python
def chat(
    self,
    session_id: str,
    message: str,
    interaction_mode: Literal["chat", "component"] | None = None,
    enthusiasm_level: Literal["standard", "high"] | None = None,
) -> ChatResponse:
    """处理聊天消息"""

    # 1. 获取会话锁（线程安全）
    session_lock = self._get_session_lock(session_id)
    with session_lock:
        now = time.monotonic()
        self._session_last_seen[session_id] = now

        # 创建性能跟踪器
        tracker = PerformanceTracker(f"chat session {session_id}")

        # 2. 加载或创建会话
        session = self.sessions.get(session_id)
        if session is None:
            session = self._load_session_state(session_id)
        if session is None:
            session = SessionState()  # 新会话
        self.sessions[session_id] = session

        # 3. 更新会话配置
        if interaction_mode in ("chat", "component"):
            session.interaction_mode = interaction_mode
        if enthusiasm_level in ("standard", "high"):
            session.enthusiasm_level = enthusiasm_level
        if session.model_provider is None:
            session.model_provider = self._cached_model_provider
            session.model_status_detail = self._cached_model_status_detail

        # 4. 获取上一条助手回复
        last_assistant_reply = ""
        for item in reversed(session.history):
            if item.get("role") == "assistant":
                last_assistant_reply = item.get("content", "")
                break

        # 5. 调用图引擎处理消息
        next_turn = session.turns + 1
        result = self.graph.invoke(
            message,
            requirements=session.requirements,
            enthusiasm_level=session.enthusiasm_level,
            turn_number=next_turn,
            last_assistant_reply=last_assistant_reply,
            model_provider=session.model_provider,
            template_history=session.template_history,
            interaction_mode=session.interaction_mode,
        )

        # 6. 更新会话状态
        session.requirements = result.requirements
        session.template_history = result.template_history
        session.turns = next_turn
        if result.build.cpu is not None:
            session.has_recommendation = True
        session.history.append({"role": "user", "content": message})
        session.history.append({"role": "assistant", "content": result.reply})

        # 7. 完成性能跟踪
        tracker.finish()

        # 8. 记录指标事件
        self._record_metric_event(
            session_id=session_id,
            enthusiasm_level=session.enthusiasm_level,
            turn_number=session.turns,
            has_recommendation=session.has_recommendation,
            response_mode=result.response_mode,
            fallback_reason=result.fallback_reason,
        )

        # 9. 保存会话状态
        self._save_session_state(session_id, session)

        # 10. 清理过期会话和内存缓存
        self._cleanup_expired_sessions()
        self._cleanup_in_memory_cache()

        # 11. 返回结果
        result.model_status_detail = session.model_status_detail
        return result
```

### RigForgeGraph.invoke() 执行

```python
def invoke(
    self,
    message: str,
    requirements: Optional[UserRequirements] = None,
    enthusiasm_level: Literal["standard", "high"] = "standard",
    turn_number: int = 1,
    last_assistant_reply: str = "",
    model_provider: Literal["zhipu", "openrouter", "rules"] = "rules",
    template_history: Optional[Dict[str, List[int]]] = None,
    interaction_mode: Literal["chat", "component"] = "chat",
) -> ChatResponse:
    """调用图引擎"""

    # 1. 创建初始状态
    req = requirements or UserRequirements()
    history = deepcopy(template_history) if template_history is not None else {}

    initial: GraphState = {
        "messages": [
            SystemMessage(
                content="你是RigForge（锐格锻造坊）装机顾问，风格热情专业，优先提高用户参与感并用简洁问题推进需求收集。"
            ),
            HumanMessage(content=message),
        ],
        "user_input": message,
        "requirements": req,
        "follow_up_questions": [],
        "build": BuildPlan(),
        "compatibility_issues": [],
        "estimated_power": 0,
        "route": "ask_more",
        "response_text": "",
        "enthusiasm_level": enthusiasm_level,
        "response_mode": "fallback",
        "fallback_reason": None,
        "high_cooperation": False,
        "turn_number": turn_number,
        "last_assistant_reply": last_assistant_reply,
        "model_provider": model_provider,
        "template_history": history,
        "avoid_repeat_field": None,
        "interaction_mode": interaction_mode,
    }

    # 2. 调用图引擎
    out = self.graph.invoke(initial)

    # 3. 构建响应
    turn_provider: Literal["zhipu", "openrouter", "rules"] = (
        model_provider if out.get("response_mode", "fallback") == "llm" else "rules"
    )

    return ChatResponse(
        reply=out.get("response_text", ""),
        requirements=out.get("requirements", req),
        build=out.get("build", BuildPlan()),
        compatibility_issues=out.get("compatibility_issues", []),
        estimated_power=out.get("estimated_power", 0),
        estimated_performance=self._estimate_performance_label(out.get("requirements", req)),
        enthusiasm_level=enthusiasm_level,
        response_mode=out.get("response_mode", "fallback"),
        fallback_reason=out.get("fallback_reason"),
        model_name=self._get_model_name(model_provider),
        session_model_provider=model_provider,
        turn_model_provider=turn_provider,
        build_data_source=self.build_data_source,
        build_data_version=self.build_data_version,
        build_data_mode=self.build_data_mode,
        template_history=out.get("template_history", history),
    )
```

### LangGraph 状态机执行

```python
# LangGraph 编译的图结构
graph.invoke(initial)
    ↓
# 1. collect_requirements 节点
self.collect_requirements(state)
    ↓
# 2. 路由判断
route = self.route_after_collection(state)
    ↓
# 3. 根据路由执行不同路径
if route == "ask_more":
    # → generate_follow_up → compose_reply → END
else:
    # → recommend_build → validate_build → compose_reply → END
```

### collect_requirements 节点

```python
def collect_requirements(self, state: GraphState):
    """收集需求节点"""
    # 从用户输入中提取需求
    # 调用工具集
    # 更新状态
    return updated_state
```

### recommend_build 节点

```python
def recommend_build(self, state: GraphState):
    """推荐配置节点"""
    tracker = PerformanceTracker("recommend_build")

    req = state["requirements"]

    # 1. 获取推荐上下文
    _context = self.tool_map["recommendation_context"].invoke(req.model_dump())

    # 2. 从候选中选择配置
    build = pick_build_from_candidates(req, self.tool_map["search_parts"])

    # 3. 确保预算适配
    build = ensure_budget_fit(req, build)

    tracker.finish()
    return {"build": build}
```

### validate_build 节点

```python
def validate_build(self, state: GraphState):
    """验证配置节点"""
    tracker = PerformanceTracker("validate_build")

    build = state["build"]

    # 1. 收集 SKU
    skus = []
    for key in ["cpu", "motherboard", "memory", "gpu", "psu", "case", "cooler"]:
        part = getattr(build, key)
        if part:
            skus.append(part.sku)

    # 2. 检查兼容性
    issues = self.tool_map["check_compatibility"].invoke({
        "cpu_sku": build.cpu.sku,
        "motherboard_sku": build.motherboard.sku,
        "memory_sku": build.memory.sku,
        "gpu_sku": build.gpu.sku,
        "psu_sku": build.psu.sku,
        "case_sku": build.case.sku,
        "cooler_sku": build.cooler.sku,
    })

    # 3. 估算功耗
    estimated_power = self.tool_map["estimate_power"].invoke({"parts": skus})

    # 4. 检查预算
    if build.total_price() > state["requirements"].budget_max:
        issue = f"Total price {build.total_price()} exceeds budget max {state['requirements'].budget_max}"
        issues.append(issue)

    tracker.finish()
    return {
        "compatibility_issues": issues,
        "estimated_power": estimated_power,
    }
```

### compose_reply 节点

```python
def compose_reply(self, state: GraphState):
    """组装回复节点"""
    start = time.time()
    interaction_mode = state.get("interaction_mode", "chat")
    route = state.get("route", "ask_more")

    # 根据路由生成不同回复
    if interaction_mode == "chat" and state.get("response_text"):
        existing_reply = state.get("response_text", "")
        if route == "recommend":
            return self._compose_recommendation_reply(state, existing_reply)
        else:
            return {
                "response_text": existing_reply,
                "response_mode": state.get("response_mode", "fallback"),
                "fallback_reason": state.get("fallback_reason"),
                "template_history": state.get("template_history", {}),
            }

    # 生成追问回复或推荐回复
    # 调用 LLM 或使用模板
    # 返回更新后的状态
```

---

## 完整调用链图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    服务启动阶段                              │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│  ./scripts/server.sh restart fg                              │
│       ↓                                                   │
│  start_fg() {                                            │
│      exec uvicorn rigforge.main:app                     │
│  }                                                        │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│              main.py 模块初始化                         │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 导入依赖                                │    │
│  │ 2. 定义常量                                │    │
│  │ 3. 加载环境变量                            │    │
│  │ 4. 定义辅助函数                            │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 5. 初始化配件仓库                        │    │
│  │    _bootstrap_parts_repo()                      │    │
│  │       ↓                                          │    │
│  │    rebuild_runtime_db() (如果需要)               │    │
│  │       ↓                                          │    │
│  │    repo_all = SQLitePartsRepository(...)          │    │
│  │    repo_jd = SQLitePartsRepository(...)            │    │
│  │    repo_newegg = SQLitePartsRepository(...)        │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 6. 创建聊天服务                            │    │
│  │    services = {                               │    │
│  │      "jd_newegg": _build_graph_service(...),     │    │
│  │      "jd": _build_graph_service(...),            │    │
│  │      "newegg": _build_graph_service(...),         │    │
│  │    }                                           │    │
│  │       ↓                                          │    │
│  │    _build_graph_service(repo, mode):              │    │
│  │       ↓                                          │    │
│  │       toolset = Toolset(repo, ...)            │    │
│  │       ↓                                          │    │
│  │       graph = RigForgeGraph(toolset)            │    │
│  │       ↓                                          │    │
│  │       return ChatService(graph, ...)            │    │
│  │           ↓                                      │    │
│  │           ChatService.__init__()                  │    │
│  │               ↓                                  │    │
│  │               sessions = {}                     │    │
│  │               _init_metrics_table()               │    │
│  │               _initialize_model_provider()        │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 7. 创建 FastAPI 应用                         │    │
│  │    app = FastAPI(title="RigForge｜锐格锻造坊") │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 8. 添加中间件                               │    │
│  │    app.add_middleware(CORSMiddleware, ...)      │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 9. 挂载静态文件                             │    │
│  │    app.mount("/static", StaticFiles(...))       │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 10. 定义路由                                  │    │
│  │    @app.get("/") → index()                    │    │
│  │    @app.get("/favicon.ico") → favicon()        │    │
│  │    @app.post("/api/chat") → chat()            │    │
│  │    @app.get("/api/parts") → list_parts()      │    │
│  │    @app.get("/api/metrics") → metrics()        │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│                  用户请求阶段                              │
│  POST /api/chat                                          │
│  {                                                       │
│    "session_id": "user123",                            │
│    "message": "我想配一台游戏电脑",                      │
│    "interaction_mode": "chat",                            │
│    "enthusiasm_level": "standard"                          │
│  }                                                       │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│          FastAPI 路由到 chat() 函数                      │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ @app.post("/api/chat")                            │    │
│  │ def chat(payload: ChatRequest):                   │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 规范化模式                                │    │
│  │    mode = _normalize_mode(payload.build_data_mode)│    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 路由会话 ID                              │    │
│  │    routed_session_id = f"{mode}:{session_id}"  │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 选择服务                                  │    │
│  │    active_service = services[mode]               │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 4. 调用聊天服务                            │    │
│  │    result = active_service.chat(...)              │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│           ChatService.chat() 执行                          │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 获取会话锁                              │    │
│  │    session_lock = self._get_session_lock(session_id)│    │
│  │    with session_lock:                             │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 加载或创建会话                            │    │
│  │    session = self.sessions.get(session_id)         │    │
│  │    if session is None:                          │    │
│  │        session = _load_session_state(session_id)   │    │
│  │    if session is None:                          │    │
│  │        session = SessionState()                    │    │
│  │    self.sessions[session_id] = session            │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 更新会话配置                            │    │
│  │    session.interaction_mode = interaction_mode       │    │
│  │    session.enthusiasm_level = enthusiasm_level      │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 4. 获取上一条助手回复                        │    │
│  │    last_assistant_reply = ""                   │    │
│  │    for item in reversed(session.history):          │    │
│  │        if item.get("role") == "assistant":      │    │
│  │            last_assistant_reply = item.get("content")│    │
│  │            break                                 │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 5. 调用图引擎处理消息                    │    │
│  │    result = self.graph.invoke(...)               │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 6. 更新会话状态                            │    │
│  │    session.requirements = result.requirements     │    │
│  │    session.history.append(...)                  │    │
│  │    session.turns = next_turn                  │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 7. 完成性能跟踪                              │    │
│  │    tracker.finish()                             │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 8. 记录指标事件                              │    │
│  │    _record_metric_event(...)                  │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 9. 保存会话状态                              │    │
│  │    _save_session_state(session_id, session)      │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 10. 清理过期会话和内存缓存                   │    │
│  │    _cleanup_expired_sessions()                 │    │
│  │    _cleanup_in_memory_cache()                │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 11. 返回结果                                │    │
│  │    return result                               │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│           RigForgeGraph.invoke() 执行                       │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 创建初始状态                              │    │
│  │    initial = {                               │    │
│  │      "messages": [...],                        │    │
│  │      "user_input": message,                   │    │
│  │      "requirements": req,                     │    │
│  │      "follow_up_questions": [],                │    │
│  │      "build": BuildPlan(),                   │    │
│  │      ...                                      │    │
│  │    }                                         │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 调用图引擎                              │    │
│  │    out = self.graph.invoke(initial)              │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 构建响应                                │    │
│  │    return ChatResponse(...)                    │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│           LangGraph 状态机执行                           │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ graph.invoke(initial)                          │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. collect_requirements 节点                  │    │
│  │    self.collect_requirements(state)             │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 路由判断                                │    │
│  │    route = self.route_after_collection(state)     │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 根据路由执行不同路径                    │    │
│  │    if route == "ask_more":                    │    │
│  │        → generate_follow_up → compose_reply → END│    │
│  │    else:                                     │    │
│  │        → recommend_build → validate_build          │    │
│  │           → compose_reply → END                │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│              recommend_build 节点（如果是推荐路径）           │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 获取推荐上下文                            │    │
│  │    _context = tool_map["recommendation_context"]   │    │
│  │                .invoke(req.model_dump())       │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 从候选中选择配置                          │    │
│  │    build = pick_build_from_candidates(...)        │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 确保预算适配                              │    │
│  │    build = ensure_budget_fit(req, build)        │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│              validate_build 节点（如果是推荐路径）            │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 收集 SKU                                │    │
│  │    skus = [cpu.sku, motherboard.sku, ...]   │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 检查兼容性                              │    │
│  │    issues = tool_map["check_compatibility"]      │    │
│  │             .invoke({cpu_sku, ...})            │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 3. 估算功耗                                  │    │
│  │    estimated_power = tool_map["estimate_power"]  │    │
│  │                   .invoke({"parts": skus})      │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 4. 检查预算                                  │    │
│  │    if build.total_price() > budget_max:          │    │
│  │        issues.append(...)                      │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│              compose_reply 节点                           │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 1. 根据路由生成不同回复                    │    │
│  │    if route == "recommend":                   │    │
│  │        _compose_recommendation_reply(state)       │    │
│  │    else:                                     │    │
│  │        生成追问回复                            │    │
│  └──────────────────────────────────────────────────────┘    │
│       ↓                                                   │
│  ┌──────────────────────────────────────────────────────┐    │
│  │ 2. 调用 LLM 或使用模板                   │    │
│  │    if llm:                                   │    │
│  │        reply = llm.invoke(...)                │    │
│  │    else:                                     │    │
│  │        reply = _fallback_reply(...)            │    │
│  └──────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────────┐
│              返回 JSON 响应                              │
│  {                                                       │
│    "reply": "...",                                      │
│    "requirements": {...},                                  │
│    "build": {...},                                       │
│    "compatibility_issues": [...],                           │
│    "estimated_power": 0,                                 │
│    "response_mode": "llm",                               │
│    "model_name": "glm-4.7-flash",                         │
│    ...                                                   │
│  }                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 关键函数入口点

| 阶段 | 入口函数 | 文件 | 说明 |
|------|---------|------|------|
| **服务启动** | `uvicorn rigforge.main:app` | server.sh | 启动 ASGI 服务器 |
| **模块初始化** | `main.py` 模块级代码 | main.py | 执行模块初始化代码 |
| **请求处理** | `chat(payload: ChatRequest)` | main.py | FastAPI 路由处理 |
| **会话管理** | `ChatService.chat()` | service.py | 会话状态管理 |
| **图执行** | `RigForgeGraph.invoke()` | graph.py | LangGraph 状态机执行 |
| **节点执行** | `collect_requirements()` | graph.py | 收集用户需求 |
| **节点执行** | `recommend_build()` | graph.py | 推荐硬件配置 |
| **节点执行** | `validate_build()` | graph.py | 验证配置兼容性 |
| **节点执行** | `compose_reply()` | graph.py | 生成自然语言回复 |

---

## 架构特点

### 状态机模式

本项目使用 **LangGraph 状态机**，而非 ReAct 模式：

**特点**：
- ✅ 固定流程：预定义的节点和边
- ✅ 单向执行：无循环，不回退
- ✅ 固定工具调用：每个节点调用特定工具
- ✅ 无观察反馈：工具结果不改变流程

**流程图**：
```
collect_requirements → [路由判断] → {
    ask_more → generate_follow_up → compose_reply → END
    recommend → recommend_build → validate_build → compose_reply → END
}
```

### 与 ReAct 模式的区别

| 维度 | 状态机（当前） | ReAct |
|------|---------------|--------|
| **流程** | 固定 | 循环 |
| **决策者** | 预定义路由函数 | LLM |
| **工具选择** | 固定节点调用 | LLM 动态选择 |
| **反馈机制** | 无反馈循环 | 观察 → 思考 |
| **灵活性** | 低 | 高 |
| **LLM 调用次数** | 1-2 次/轮 | 3-5 次/轮 |
| **成本** | 低 | 高 |

### 为什么状态机适合本项目？

1. **任务流程固定**：PC 装机推荐有明确的步骤
2. **性能优势**：LLM 调用次数少，成本低
3. **可控性强**：流程可预测，易于调试
4. **易于维护**：新人容易理解，测试简单

---

## 总结

RigForge 项目的完整调用链路从服务启动到请求处理，经过以下阶段：

1. **服务启动**：`server.sh` → `uvicorn` → `main.py`
2. **模块初始化**：加载配置、创建服务、定义路由
3. **请求处理**：`FastAPI` → `ChatService` → `RigForgeGraph`
4. **状态机执行**：`collect_requirements` → 路由 → `recommend_build`/`generate_follow_up` → `compose_reply`
5. **返回响应**：JSON 格式的聊天响应

整个流程清晰、可控，适合固定流程的 PC 装机推荐任务。
